from __future__ import annotations

import os
import subprocess
import sys
import tempfile
import traceback
from dataclasses import dataclass
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, TypedDict

from langgraph.graph import END, START, StateGraph

from ds_star_agents import (
    AnalyzerAgent,
    AnalyzerDebuggerAgent,
    CoderAgent,
    FinalyzerAgent,
    PlannerAgent,
    RouterAgent,
    SolutionDebuggerAgent,
    TracebackSummarizerAgent,
    VerifierAgent,
)
from ds_star_core import format_data_info, format_plan_steps, load_prompts


class VerificationResult(Enum):
    """Result from the verifier agent."""

    SUFFICIENT = "sufficient"
    INSUFFICIENT = "insufficient"


@dataclass
class DataDescription:
    """Description of a data file generated by the analyzer agent."""

    file_path: str
    description: str
    script: str


@dataclass
class ExecutionResult:
    """Result from executing a Python script."""

    success: bool
    output: str
    error: Optional[str] = None
    traceback: Optional[str] = None


class DSStarState(TypedDict, total=False):
    query: str
    data_files: List[str]
    data_descriptions: List[DataDescription]
    plan: List[str]
    code: str
    execution_results: List[str]
    last_execution: ExecutionResult
    iteration: int
    verification: VerificationResult
    verifier_response: str
    router_decision: str
    finalization_reason: str
    final_code: str
    final_plan: List[str]
    final_execution_results: List[str]


class DSSTAR:
    """
    LangGraph implementation of the DS-STAR multi-agent framework.
    """

    def __init__(
        self,
        llm_client: Any,
        max_refinement_rounds: int = 10,
        max_debug_attempts: int = 3,
        use_retriever: bool = False,
        top_k_files: int = 10,
        prompts_dir: str = "prompts",
        verbose: bool = True,
    ):
        self.llm_client = llm_client
        self.max_refinement_rounds = max_refinement_rounds
        self.max_debug_attempts = max_debug_attempts
        self.use_retriever = use_retriever
        self.top_k_files = top_k_files
        self.prompts_dir = prompts_dir
        self.verbose = verbose

        self.prompts = load_prompts(prompts_dir)

        self.analyzer_agent = AnalyzerAgent(llm_client, self.prompts.get("analyzer", ""))
        self.analyzer_debugger = AnalyzerDebuggerAgent(
            llm_client, self.prompts.get("debugger_analyzer", "")
        )
        self.solution_debugger = SolutionDebuggerAgent(
            llm_client, self.prompts.get("debugger_solution", "")
        )
        self.traceback_summarizer = TracebackSummarizerAgent(
            llm_client, self.prompts.get("debugger_summarize", "")
        )
        self.planner_agent = PlannerAgent(
            llm_client,
            initial_prompt=self.prompts.get("planner_initial", ""),
            next_prompt=self.prompts.get("planner_next", ""),
        )
        self.coder_agent = CoderAgent(
            llm_client,
            initial_prompt=self.prompts.get("coder_initial", ""),
            next_prompt=self.prompts.get("coder_next", ""),
        )
        self.verifier_agent = VerifierAgent(llm_client, self.prompts.get("verifier", ""))
        self.router_agent = RouterAgent(llm_client, self.prompts.get("router", ""))
        self.finalyzer_agent = FinalyzerAgent(llm_client, self.prompts.get("finalyzer", ""))

        self.graph = self._build_graph()

    def _build_graph(self):
        graph = StateGraph(DSStarState)

        graph.add_node("analyze", self._node_analyze)
        graph.add_node("planner_initial", self._node_planner_initial)
        graph.add_node("coder_initial", self._node_coder_initial)
        graph.add_node("execute", self._node_execute)
        graph.add_node("verify", self._node_verify)
        graph.add_node("router", self._node_router)
        graph.add_node("planner_next", self._node_planner_next)
        graph.add_node("coder_next", self._node_coder_next)
        graph.add_node("finalize", self._node_finalize)

        graph.add_edge(START, "analyze")
        graph.add_edge("analyze", "planner_initial")
        graph.add_edge("planner_initial", "coder_initial")
        graph.add_edge("coder_initial", "execute")
        graph.add_edge("execute", "verify")
        graph.add_conditional_edges(
            "verify",
            self._route_after_verify,
            {
                "verified": "finalize",
                "maxed": "finalize",
                "continue": "router",
            },
        )
        graph.add_edge("router", "planner_next")
        graph.add_edge("planner_next", "coder_next")
        graph.add_edge("coder_next", "execute")
        graph.add_edge("finalize", END)

        return graph.compile()

    def set_prompt(self, agent_name: str, prompt: str):
        """Set the prompt for a specific agent and update the bound agent instance."""
        if agent_name not in self.prompts:
            raise ValueError(f"Unknown agent: {agent_name}")
        self.prompts[agent_name] = prompt

        if agent_name == "analyzer":
            self.analyzer_agent.prompt = prompt
        elif agent_name == "planner_initial":
            self.planner_agent.initial_prompt = prompt
        elif agent_name == "planner_next":
            self.planner_agent.next_prompt = prompt
        elif agent_name == "coder_initial":
            self.coder_agent.initial_prompt = prompt
        elif agent_name == "coder_next":
            self.coder_agent.next_prompt = prompt
        elif agent_name == "verifier":
            self.verifier_agent.prompt = prompt
        elif agent_name == "router":
            self.router_agent.prompt = prompt
        elif agent_name == "debugger_analyzer":
            self.analyzer_debugger.prompt = prompt
        elif agent_name == "debugger_solution":
            self.solution_debugger.prompt = prompt
        elif agent_name == "debugger_summarize":
            self.traceback_summarizer.prompt = prompt
        elif agent_name == "finalyzer":
            self.finalyzer_agent.prompt = prompt

    def execute_code(self, code: str, timeout: int = 30) -> ExecutionResult:
        """
        Execute Python code and return the result.
        """
        try:
            with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
                f.write(code)
                temp_file = f.name

            try:
                result = subprocess.run(
                    [sys.executable, temp_file],
                    capture_output=True,
                    text=True,
                    timeout=timeout,
                )

                if result.returncode == 0:
                    return ExecutionResult(success=True, output=result.stdout)

                return ExecutionResult(
                    success=False,
                    output=result.stdout,
                    error=result.stderr,
                    traceback=result.stderr,
                )
            finally:
                os.unlink(temp_file)
        except subprocess.TimeoutExpired:
            return ExecutionResult(
                success=False,
                output="",
                error="Execution timeout",
                traceback="Script execution exceeded timeout limit",
            )
        except Exception as exc:  # pylint: disable=broad-except
            return ExecutionResult(
                success=False,
                output="",
                error=str(exc),
                traceback=traceback.format_exc(),
            )

    def _node_analyze(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Analyzing data files...")
        data_descriptions: List[DataDescription] = []
        for data_file in state.get("data_files", []):
            data_descriptions.append(self._analyze_file(data_file))

        if self.use_retriever and len(data_descriptions) > self.top_k_files:
            data_descriptions = self.retrieve_relevant_files(state.get("query", ""), data_descriptions)

        return {"data_descriptions": data_descriptions}

    def _analyze_file(self, data_file: str) -> DataDescription:
        script = self.analyzer_agent.generate_script(data_file)
        current_script = script
        description = ""
        for attempt in range(self.max_debug_attempts):
            result = self.execute_code(current_script)
            if result.success:
                description = (result.output or "").strip()
                break

            if attempt < self.max_debug_attempts - 1 and self.analyzer_debugger.configured:
                summarized = self._summarize_traceback(result.traceback or result.error or "")
                current_script = self.analyzer_debugger.debug(current_script, summarized)
            else:
                description = (
                    f"ERROR: Failed to analyze file after {self.max_debug_attempts} attempts.\n"
                    f"{(result.error or result.output or '').strip()}"
                )

        return DataDescription(file_path=data_file, description=description, script=current_script)

    def _node_planner_initial(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Generating initial plan...")
        data_info = format_data_info(state.get("data_descriptions", []))
        initial_step = self.planner_agent.generate_initial(state["query"], data_info)
        return {"plan": [initial_step]}

    def _node_coder_initial(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Implementing initial plan...")
        data_info = format_data_info(state.get("data_descriptions", []))
        code = self.coder_agent.generate_initial(state["plan"][0], data_info)
        return {"code": code, "execution_results": []}

    def _node_execute(self, state: DSStarState) -> Dict[str, Any]:
        data_info = format_data_info(state.get("data_descriptions", []))
        code_in = state.get("code", "")
        self._log("Executing solution code...")
        code, exec_result = self._execute_with_debugging(code_in, data_info)
        execution_results = list(state.get("execution_results", []))
        execution_results.append(self._execution_observation(exec_result))
        return {
            "code": code,
            "last_execution": exec_result,
            "execution_results": execution_results,
        }

    def _execute_with_debugging(self, script: str, data_info: str) -> Tuple[str, ExecutionResult]:
        current_script = script
        last_result = ExecutionResult(success=False, output="")
        for attempt in range(self.max_debug_attempts):
            result = self.execute_code(current_script)
            last_result = result
            if result.success:
                return current_script, result

            if attempt < self.max_debug_attempts - 1 and self.solution_debugger.configured:
                summarized = self._summarize_traceback(result.traceback or result.error or "")
                current_script = self.solution_debugger.debug(current_script, summarized, data_info)

        return current_script, last_result

    def _node_verify(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Verifying plan sufficiency...")
        plan_steps = format_plan_steps(state.get("plan", []))
        result_text = self._execution_observation(state.get("last_execution"))
        response = self.verifier_agent.verify(
            plan_steps=plan_steps,
            query=state["query"],
            code=state.get("code", ""),
            result=result_text,
        )
        verification = (
            VerificationResult.SUFFICIENT if "yes" in response.lower() else VerificationResult.INSUFFICIENT
        )
        iteration = state.get("iteration", 0)
        if verification == VerificationResult.INSUFFICIENT:
            iteration += 1

        updates: Dict[str, Any] = {
            "verification": verification,
            "verifier_response": response.strip(),
            "iteration": iteration,
        }

        if verification == VerificationResult.SUFFICIENT:
            updates["finalization_reason"] = "verified"
        elif iteration >= self.max_refinement_rounds:
            updates["finalization_reason"] = "max_rounds"

        return updates

    def _route_after_verify(self, state: DSStarState) -> str:
        verification = state.get("verification")
        if verification == VerificationResult.SUFFICIENT:
            return "verified"
        if state.get("iteration", 0) >= self.max_refinement_rounds:
            return "maxed"
        return "continue"

    def _node_router(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Routing next action...")
        plan_steps = format_plan_steps(state.get("plan", []))
        last_result = self._execution_observation(state.get("last_execution"))
        data_info = format_data_info(state.get("data_descriptions", []))
        decision = self.router_agent.decide(
            plan_steps=plan_steps,
            query=state["query"],
            last_result=last_result,
            data_info=data_info,
            num_steps=len(state.get("plan", [])),
        )
        return {"router_decision": decision}

    def _node_planner_next(self, state: DSStarState) -> Dict[str, Any]:
        plan = self._truncate_plan(state.get("plan", []), state.get("router_decision", "Add Step"))
        self._log("Generating next plan step...")
        data_info = format_data_info(state.get("data_descriptions", []))
        last_result = self._execution_observation(state.get("last_execution"))
        next_step = self.planner_agent.generate_next(plan, state["query"], last_result, data_info)
        plan.append(next_step)
        return {"plan": plan}

    def _truncate_plan(self, plan: List[str], decision: str) -> List[str]:
        if decision.lower() == "add step":
            return list(plan)
        try:
            step_index = int(decision)
            l = max(0, step_index - 1)
            return list(plan[: l + 1])
        except (ValueError, TypeError):
            return list(plan)

    def _node_coder_next(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Implementing updated plan...")
        data_info = format_data_info(state.get("data_descriptions", []))
        plan = list(state.get("plan", []))
        previous_code = state.get("code", "")
        code = self.coder_agent.generate_next(plan, state["query"], previous_code, data_info)
        return {"code": code}

    def _node_finalize(self, state: DSStarState) -> Dict[str, Any]:
        self._log("Finalizing solution...")
        data_info = format_data_info(state.get("data_descriptions", []))
        code = state.get("code", "")
        result_text = self._execution_observation(state.get("last_execution"))
        final_code = self.finalyzer_agent.finalize(
            query=state["query"],
            code=code,
            result=result_text,
            data_info=data_info,
            guidelines="",
        )
        return {
            "final_code": final_code,
            "final_plan": list(state.get("plan", [])),
            "final_execution_results": list(state.get("execution_results", [])),
            "finalization_reason": state.get("finalization_reason", "verified"),
        }

    def _summarize_traceback(self, error_traceback: str) -> str:
        if not error_traceback:
            return ""
        return self.traceback_summarizer.summarize(error_traceback)

    def _execution_observation(self, execution: Optional[ExecutionResult]) -> str:
        if execution is None:
            return ""
        if execution.success:
            return (execution.output or "").strip()
        return (execution.error or execution.output or "").strip()

    def _log(self, message: str):
        if self.verbose:
            print(message)

    def retrieve_relevant_files(
        self,
        query: str,
        data_descriptions: List[DataDescription],
    ) -> List[DataDescription]:
        if len(data_descriptions) <= self.top_k_files:
            return data_descriptions
        return data_descriptions[: self.top_k_files]

    def solve(self, query: str, data_files: List[str]) -> Tuple[str, List[str], List[str]]:
        initial_state: DSStarState = {
            "query": query,
            "data_files": data_files,
            "plan": [],
            "execution_results": [],
            "iteration": 0,
        }

        final_state = self.graph.invoke(initial_state)

        final_code = final_state.get("final_code") or final_state.get("code", "")
        final_plan = final_state.get("final_plan") or final_state.get("plan", [])
        execution_results = final_state.get("final_execution_results") or final_state.get(
            "execution_results", []
        )
        return final_code, final_plan, execution_results
